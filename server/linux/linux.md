# 리눅스

## 리눅스 개요와 기본 개념

### 리눅스와 GNU 프로젝트

리눅스는 Gnu is not Unix의 줄임말인 GNU 프로젝트의 일환인 오픈소스 운영체제.

리눅스의 구조는 컴퓨터 하드웨어,\
하드웨어 제어 소프트웨어와 커뮤니케이션을 돕는 시스템 관리자 역할인 kernel,\
사용자의 명령어를 해석하여 kernel 에게 전달하는 shell,\
각종 응용 프로그램들로 이루어져 있음.

### 리눅스의 특징과 패키지 관리

리눅스는 유닉스라는 운영체제 기반\
멀티 유저와 멀티 태스킹 지원\
CLI 및 GUI 모두 지원\
네트워크 기능 활성화로 서버 os로 적합.

패키지: 응용프로그램을 이미 빌드한 상태로 따로 컴파일 하지 않고 설치할 수 있게 도와주는 시스템.

### 우분투 리눅스의 특징

리눅스의 운영체제중 가장 유명한 것은 우분투.\
특징: 개인용 PC 환경에 최적화, 간결하고 쉬움, 많은 사용자, 6개월 단위의 짧은 업데이트 기간.\
우분투의 버전 넘버 4자리중 앞의 두자리는 년도, 뒤의 두자리는 월.\
우분투 LTS 버전은 긴 기간을 지원하는 가장 안정적인 버전.

### 리눅스 기본 명령어와 쉘

명령어는 Shell을 통해 Kernel로 영어 명령을 일의 목록이나 파일로 번역하여 전달.\
shell의 종류는 bash, Sh, csh, Ksh가 있음.

### 리눅스 기초 명령어

- `whoami || in -un` : 로그인한 사용자 ID를 알려주는 명령어
- `passwd` : 로그인한 사용장의 비밀번호를 변경하는 명령어 (password)
- `pwd` : 현재 디렉토리 위치를 출력 (Print Working Directory)
- `ls` : 현재 디렉토리의 목록을 출력 (list)
- `ls -l` : 현재 디렉토리의 목록을 tkdtpgl 출력 (list -long)
- `ls -a` : 숨겨진 파일이나 디렉토리를 포함하여 출력 (list = -all)
- `ls -al` : 숨겨진 파일과 디렉토리를 포함하여 현재 디렉토리의 목록을 상세히 출력 (list -all long)
- `cd` : 해당 디렉토리로 이동 (change directory)
- `명령어 --help` : 사용하고자 하는 명령어 뒤에 붙여서 사용, 명령어에 대한 사용 방법이 출력

### CLI와 GUI의 차이점

- GUI : 사용자가 편리하게 사용할 수 있도록 기능을 아이콘, 이미지 등의 그래픽으로 나타낸 인터페이스
- CLI : 문자로 컴퓨터와 상호작용하여 동작하는 인터페이스. CMD, Terminal 로 사용 가능

### 우분투 패키지 관리: APT

우븐투에서는 패키지 관리자로 apt(Advanced Packaging Tool)를 사용.\
데비안 리눅스 또는 파생된 배포판에서 소프트웨어를 설치, 제거, 업데이트 할 때 사용.

- `apt install` : 설치
- `apt remove` : 삭제
- `apt search` : 검색
- `apt update` : 패키지 리스트 최신화
- `apt show` : 설명

sudo 라는 키워드를 통해 apt 권환 휙득 가능.

### 루트 사용자와 권한 관리

`root` : 리눅스에서 모든 권한을 가지고 있는 최고 관리자를 뜻함.\
`sudo 사용할 명령어` 의 방식으로 권환 뢱득 가능.

## 리눅스 파일 시스템과 디렉토리 구조

### 리눅스 파일 시스템 구조

디렉토리 + 파일의 형태로 구성되어 있음.

- FAT : 파일 할당 테이블, 메모리 카드에 쓰임, 공간 활용 좋지 못함, 낮은 호환성.
- NTFS : 윈도우즈 NT계열(FAT 대체), 안정성 높음, 보완성 높음.
- EXT : EXT4 사용중, 빠른 데이터 탐색, 초대형 파일 시스템.

## 리눅스 디렉토리 구조

리눅스의 파일 시스템은 root를 기준으로 트리 디렉토리 구조.

- `bin` : 명령어를 저장하는 폴더
- `boot` : 부팅 세팅을 저장하는 폴더
- `etc` : 대부분의 설정 파일을 저장하는 폴더
- `home` : 사용자의 계정 폴더
- `lib` : 프로그램에서 쓰이는 라이브러리를 저장하는 폴더

`tree` 명령문을 통해 확인 가능.\
`sudo apt install tree`

## 파일 소유권과 권한 관리

소유권과 권한.\
`ls -al` 명령어를 통해 파일 속성 확인 가능.

### 파일 속성 순서

- 파일 유형 : - 은 파일, d는 폴더

- 파일 권한 : 소유자, 그룹, 그 외 사용자 순으로 구성되어 있으며
각각 r(4)은 읽기, w(2)는 쓰기, x(1)는 실행 권한을 뜻하는 알파벳 세개로 이루어져 있음.

- 링크수 : ln 명령어를 통해 링크된 수

- 파일 소유자 : 파일을 만들고 사용할 수 있는 소유자

- 소유 그룹 : 사용자의 그룹

- 파일 크기 : Byte 단위

- 마지막 변경 시간

- 파일 이름

파일의 권한 변경(change mod)은 `chmod + 각각 세자리의 권한 숫자의 합계 + 변경할 파일 위치 또는 이름` 으로 가능.

소유권 변경(change owner)은 `chown + 소유 할 유저:소유 할 그룹 + 소유권 변경하고 싶은 디렉토리 or 파일명` 으로 가능.\
단, root 권한 필수.

### 디렉토리와 파일 생성 및 삭제

- `mkdir + 생성할 디렉토리 이름` or `mkdir + 디렉토리 경로/ 디렉토리 명` : 디렉토리 생성 (make directory).

- `touch + 생성할 파일 이름` or `touch + 디렉토리 경로/ 파일 명` : 빈파일 생성.

- `rmdir + 삭제할 디렉토리 이름` : 디렉토리 삭제, 단 해당 디렉토리가 비어 있어야 함.

- `rm + 옵션 + 삭제할 파일 및 디렉토리 명` : 파일 디렉토리 삭제.
  - rm의 otpion :\
    `-r` : 디렉토리와 그 하부 파일까지 삭제.\
    `-f` : 삭제 여부를 묻지 않고 바로 삭제.\
    `-i` : 삭제할 것인지 확인.\
    `-rf` : 삭져 여부를 묻지 않고 하부 파일이 있는 디렉토리까지 삭제.

### 파일 복사 및 이동

- `cp + 옵션 + 대상 위치 및 이름 + 복사하고 싶은 위치`
  - cp의 option :\
    `-r` : 하위 디렉토리와 파일 전체를 복사.\
    `-p` : 소유주, 그룹, 권한, 시간 정보를 그대로 복사.

- `mv + 대상 위치/ 이름 + 이동하고 싶은 위치 이름` : 파일 및 디렉토리 이동.

- `cat + 옵션 + 파일 이름` : 파일 내용 출력
  - cat의 option :\
    `-n` : 왼쪽에 줄 번호와 함께 내용을 출력한다.\
    `>` : 파일의 내용을 덮어 쓴다.\
    `뒤로 갈 + >> + 기존 파일` : 파일의 내용이 있다면 뒤에 내용을 추가한다.

- `find + 파일 경로  + "파일 혹은 폴더 이름" + 파일 혹은 폴더 타입` : 파일 검색.
  - 경로 : /디렉토리 이름.
  - 이름 : -name + 파일 혹은 폴더 이름.
  - 타입이 폴더일 경우 : -type d
  - 타입이 파일일 경우 : -type f

- `사용하려는 명령어 + --help` : 명령어 옵션 확인

### 파일 내용 확인 및 검색

- `파일 이름 + head + -N숫자` : 처음 N줄을 출력.
- `파일 이름 + tail + -N숫자` : 마지막 N줄을 출력.
- `more + 파일 이름 + 엔터 + 스페이스바` : 화면 단위 출력.
- `which + 파일 이름` : 절대경로.
- `su + 바꿀 계정 or su + root` : 현재 로그인된 계정을 다른 계정으로 변경.

- `diff` : 파일 비교.
- `alias` : 지정 명령어.
- `wc` : 라인, 단어의 수.
- `shutdown` : 시스템 종료.

### nano 에디터 사용법

- nano editor : UNIX 호환 시스템에서 사용 가능한 가볍고 간단한 텍스트 에디터.

- 사용 방법 : `nano + 편집하려는 파일 이름`

#### 단축키

- `ctrl + O` : 저장하기.
- `ctrl + X` : 종료하기.
- `ctrl + W` : 검색하기.
- `alt + 6` : 복사하기.
- `ctrl + U` : 붙여넣기.
- `ctrl + ^` : 여러 줄 선택.

## 정규 표현식과 파일 리디렉션

### 정규 표현식(Regular Expression)

정규표현식은 특정한 규칙을 가진 문자열의 집합을 표현하는 데 사용하는 일종의 형식이며 주로 검색과 치환에 사용.

#### 대표적인 정규식 메타 문자

- `^ + 검색규칙` : 규칙이 문자열의 시작인 경우에만 검색.
- `$ + 검색규칙` : 규칙이 문자열의 끝인 경우에만 검색.
- `문자 + . + 문자` : 문자 사이의 하나의 문자와 대응.
- `\d` : 숫자만 검색.
- `\D` : 숫자가 아닌 것만 검색.
- `\w` : 알파벳 대소문자, 숫자, 언더스코어를(`_`)를 검색.
- `\s` : 공백문자(스페이스) 입력을 검색.
- `\b` : 단어 구분자를 찾아주는 정규표현식.
- `\W` : `\w`에 해당하지 않는 것을 검색.
- `\S` : `\s`에 검색되지 않는, 공백문자가 아닌 것을 검색.
- `\n` : 개행문자(엔터), 줄을 바꾸는 문자를 검색.
- `\` + 메타문자 : 메타 문자를 그대로 검색.
- `\t` : 탭 문자를 검색.

#### 선택 패턴은 사용자가 만든 규칙을 검색할 수 있는 기능

- `규칙1 + | + 규칙2` : 규칙1 또는 규칙2 하나만 만족하는 것을 검색.
- `[ + 문자 + ]` : 대괄호 속에 넣은 문자 중에서 하나만 매칭이 되어도 검색, 대소문자 구분, 대괄호 속 ^ 기호는 not의 의미를 가짐.

#### 수량 한정자는 문자의 갯수를 나타내는 표현식

- `문자 + ?` : 문자 끝 단어가 없는 경우(0)와 있는 경우(1)를 모두 검색(있을 수도 있고 없을 수도 있을 때 사용).
- `문자 + *` : 0개 이상일 경우, 문자의 단어가 하나 이상 포한된 것을 검색.
- `문자 + +` : 문자 끝 단어가 1개 이상 포함될 경우 검색.
- `문자 + { + 숫자 + }` : 문자가 숫자 만큼 있는 경우 검색. {}
- `문자 + { + 숫자1,숫자2 + }` : 문자가 숫자1 이상, 숫자2 이하를 포함할 경우 검색. {}
- `문자 + { + 숫자, + }` : 문자가 숫자개 이상의 문자를 검색. {}

#### 그룹 패턴은 괄호를 이용해 한 번 사용한 패턴을 여러번 사용하게 하는 표현식

괄호로 표현식을 묶고 `\`숫자로 재사용 가능.\
ex) `(표현식1)(표현식2)` => `/1` 일 경우 표현식 1을 재사용, `(to)ma\1` 는 tomato 로 치환.

#### 정규 표현식 사용 예

규칙 :

1. 전화번호는 010으로 시작
2. 가운데 자리는 네 자리
3. 각 자리에 구분문자가 있을 수도 있고 , 없을 수도 있음

규칙을 만족하는 전화번호를 검색 : `^010(\D?\d{4}){2}`

- `^010` : 시작 문자는 010
- `\D?` : 숫자가 아닌 구분문자가 0개 이상
- `\d{4}` : 숫자가 4개
- `(\D?\d{4}){2}` : 숫자 4개를 표현하는 `(\D?\d{4})` 가 2개 존재

### grep 명령어

grep(Global Regular Expression Print)은 명령은 파일 내에서 지정한 패턴이나 문자열을 찾은 후에 그 패턴을 포함하고 있는 모든 행을 출력.

#### 그랩의 기본 형태

grep + 옵션 + 패턴 + 파일명 or

대표적 option :

- `-i` : 대소문자를 구분하지 않고 검색.
- `-v` : 패턴과 일치하지 않는 행을 출력.
- `-c` : 패턴과 일치하는 행의 개수를 출력.
- `-w` : 패턴과 단어 단위로 매칭되어야 출력.

#### grep 예시

`grep zima hello.txt`\
: hello.txt 파일에서 'zima' 라는 문자열이 들어 있는 행을 모두 출력.

`grep -c zima hello.txt`\
: hello.txt 파일에서 'zima' 라는 문자열이 들어 있는 행의 수 출력.

`grep [0-9] hello.txt`
: hello.txt 파일에서 숫자가 존재하는 행을 모두 출력.

`grep "Elice\.The\.Rabbit *`
: 현재 디렉토리의 모든 파일에서 Elice.The.Rabbit 을 찾아 출력.

`grep -v ^# somecode`
: somecode 파일에서 #으로 시작하지 않는 행을 모두 출력.

`grep '\<[a-z].*e\>' zima`
: zima 파일에서  <> 안에서 소문자로 시작하고 공백을 포함한 여러 문자가 나오며,
e로 끝나는 단어가 포함된 행을 모두 출력.

`cat 파일명 | grep "단어"`
: 파일 안에서 단어를 포한하는 행을 출력(pipe 사용)

### 파일 리디렉션(File Redirection)

File Redirection은 일반적인 표준 입력 및 출력 그리고 오류를 사용하지 않고 다른 경로인 파일로 재지정하는 것을 뜻함.

표준 스트림은 표준 입력, 표준 출력, 표준 오류 출력으로 분류, 문자열로 콘솔에 출력되도록 설정.

- `stdin` : 키보드 입력
- `stout` : 화면 출력(cat, ls ....)
- `stderr` : 오류 내용 출력

- `<` 연산자는 표준입력을 재지정.

- `>` 연산자는 표준 출력을 재지정.
ex) `ls > ls,txt` 이라면 ls를 입력했을 때 출력되는 폴더를 ls.txt에 저장

- `>>` 연산자는 파일이 존재하지 않다면 파일을 생성, 존재한다면 파일 내용을 지우지 않고 이어서 작성.

표준오류는 연산자를 사용하지 않으며 파일 디스크립터 번호를 `>` 앞에 작성하여 사용.

- 0 : 표준 입력
- 1 : 표준 출력
- 2 : 표준 에러

#### 예시

`cat < hello.txt > zima.txt`

1. hello.txt의 내용을 cat 멸령어의 입력 스트림으로 전송
2. cat 명령어는 hello.txt 파일의 내용을 출력
3. cat 명령어의 출력 스트림을 zima.txt로 변경
4. cat 명령어의 출력 스트림은 화면이 아닌 zima.txt에 저장

`python hello.py < input.txt >> result.txt`

1. input.txt의 내용을 python 파일 hello.py의 입력 스트림으로 전송
2. python파일 hello.py 실행
3. python파일 hello.py의 출력 스트림을 result.txt로 변경
4. python파일 hello.py의 출력 스트림은 화면이 아닌 result.txt에 저장

python 파일을 실행하려면 파일 앞에 pyton 명령어를 쳐줘야함.

`python add.py < input.txt > output.txt`
: python 파일인 add.py의 코드를 실행하고,
input.txt를 입력 스트림으로 사용하여,
결과물을 output.txt에 저장.

input.txt에 값을 입력하면, add.py에 있는 식이 계산을 하고, 계산된 값을 output.txt에 저장.

input.txt에는 "1"이 저장되어 있고,
add.py에는 "입력값 + 3" 이 작성되어 있어서,
output.txt를 출력하면 "4"가 출력된.

### 파이프(Pipe)와 필터(Filter)

piping commands는 복잡한 명령어를 쉽게 이용할 수 있게 해주는 명령어.\
pipe는 둘 이상의 명령어를 묶어 출력의 결과를 다른 명령으로 전환할 수 있는 기능.\
명령어의 표준 출력을 또 다른 명령어의 표준 입력으로 연결.\
`|` 기호를 사용하여 명령어와 명령어를 연결.

### 파이프 예시1

`head a.txt | grep [0-9]`

1. head 명령을 실행하여 a.txt의 첫 10줄을 출력.
2. 출력된 결과를 | (pipe)를 통해 grep 명령으로 전달.
3. 숫자가 포한된 행을 가진 행의 결과가 모두 출력.

Pipe와 Redirection을 조합하여 사용하면 효율적인 작업 가능

### 파이프 예시2

`head a.txt | grep [0-9] > result.txt`

1. head 명령을 실행하여 a.txt의 첫 10줄을 출력.
2. 출력된 결과를 | (pipe)를 통해 grep 명령으로 전달.
3. 숫자가 포한된 행을 가진 행의 결과가 모두 출력.
4. 출력된 결과를 result.txt에 저장

`ls | grep user01 > output.txt`

1. ls 명령을 실행(현재 디렉토리의 디렉토리/파일 명 출력).
2. ls 명령의 결과를 입력 값으로 한 grep 명령어 실행.
3. user01 이라는 이름을 가진 파일의 결과가 출력.
4. grep 명령어의 출력 스트림은 output.txt에 저장

`cat input.txt | python add.py >> output.txt`
: 파일 리디렉션의 예시와 흡사하니 참고.

1. cat input.txt 로 input.txt 의 값인 1이 python add.py에 Pipe로 연결 됨.
2. python파일 hello.py 실행.
3. python파일 hello.py의 출력 스트림을 output.txt로 변경.
4. python파일 hello.py의 출력 스트림은 화면이 아닌 output.txt에 저장.

#### Pipe와 Redirection의 차이

Redirection은 파일을 표준 스트림으로 사용하여, input.txt의 내용 자체를 파이썬 코드의 입력값으로 넣어주는 것.

Pipe는 각 프로세스가 다른 프로세스를 표준 입력 스트림으로 사용하여, `cat input.txt` 명령어 프로세스의 출력 결과를 파이썬 코드가 입력값으로 사용하는 것.

### 표준 입출력과 에러 처리

mount란 물리적인 저장 장치(보조 기억 장치)를 디렉토리 또는 폴더에 연결시켜주는 것.\
윈도우에서는 물리적인 저장 장치를 연결하면 자동으로 폴더에 연결됨(Plug and Play).\
리눅스의 경우 마운트를 수동으로 작업해줘야 함.

#### mount 명령어의 기본형태

- `mount + 옵션 + 디바이스명 + 연결될 디렉토리명`
  - option:\
    `-a` : /etc/fstab 에 명시된 파일 시스템을 마운트 할 때 사용.\
    `-t` : 파일 시스템의 유형을 지정, 생략할 시 /etc/fstab 파일을 참조.\
    `-o` : 추가적인 설정을 적용할 때 사용, 다수의 조건을 적용할 때는 콤마(,)로 구분.

#### mount를 취소하는 명령어

- `remount + 디바이스명 + 취소를 원하는 디렉토리명`

#### 현재 mount 된 디스크 정보 출력

- `df`

#### 디바이스의 파일 시스템 명 확인

- `fdist -l`

## 리눅스 시스템 관리와 네트워킹

### 프로세스 관리

프로세스는 메모리에 적재되어 실행되고 있는 모든 프로그램.\
프로그램은 코드(명령어) 집합체, 프로세스는 프로그램의 실행 과정.\
프로그램 안에서 여러 프로세스가 생성되는 것을 멀티 프로세싱이라고 하며 운영체제에 의해 관리됨.

#### 프로그램의 특징

1. 모든 프로그램은 실행시 하나 이상의 프로세스를 갖음.
2. 병행적으로 실행이 가능하며 부모, 자식 프로세스 관계를 갖음. 자식 프로세스는 fork를 통해 자기 자신을 복사한 프로세스이며 부모 프로세스는 원본 프로세스를 뜻함.
3. kernel에 의해 관리됨.
4. 모든 프로세스는 소유자가 있음.
5. 프로세스마다 식별을 위한 고유한 ID(PID)가 부여됨.

PID는 1번은 init 프로세스, 2번은 kthreadd 프로세스가 실행.\
init 프로세스는 나머지 모든 시스템 프로세스의 부모 프로세스, 즉 프로그램을 실행할 때 생기는 프로세스는 init 프로세스를 fork 하여 생성된 프로세스.\
thread 프로세스는 thread를 만들기 위해 생성된 모든 스레드의 부모 프로세스.

#### 프로세스의 메모리 구성

- 코드 영역\
: 프로그램 코드를 뜻함, 0x0000..으로 가장 낮은 주소(하위 메모리),
코드 자체를 저장하는 메모리의 영역으로 실행하고자 하는 명령어들이 위치.

- 데이터 영역\
: 초기화된 변수들이 존재, 전역 변수와 정적 변수, 배열, 구조체 등이 존재.

- Bss 영역\
: 초기화되지 않은 변수들이 저장됨, 프로그램이 실행될 때 생성되고 종료되면 시스템에 반환.

- 힙 영역\
: 동적인 메모리 할당 영역, 낮은 주소부터 높은 주소로 쌓이며 저장, 동적으로 할당된 변수를 해제할 경우 힙 영역에서 사라짐

- 스택영역\
: 함수 매개변수, 복귀 주소, 반환값, 지역 변수와 같은 임시 자료를 저장, 함수 호출시 생성되며 함수가 끝나면 제거, 높은 주소에서부터 낮은 주소로 쌓임(LIFO).

- 커널\
: 하드웨어 제어 소프트웨어와 커뮤니케이션을 돕는 시스템 관리자, 0xFFFF..로 가장 높은주소(상위 메모리).

프로세스 메모리는 크게 커널 주소 공간(kernel space), 사용자 주소 공간으로 분리 할 수 있습니다. 이때 kernel 부분은 사용자가 접근 할 수 없음.

우리가 사용할 수 있는 공간은 stack, heap, data, text 총 4영역으로 나뉘어 지게 되는데 코드를 짤 때 사용하는 argv, argc 그 외 env, etc파일들 역시 stack부분의 일부.

사용자 주소 공간 내에 user space부분은 프로그램이 사용하는 라이브러리가 저장되는 공간이며 stack과 heap사이의 메모리 공간에 위치.

data는 Bss 와 data로 구별할 수 있는데 간단하게 Bss는 초기화 되지 않은 정적변수들이 저장되며 data는 초기화 된 변수들이 저장되는 메모리 공간.

### 그라운드 작업과 작업 제어

프로세스 명령어는 크게 조회하고 종료하는 명령어로 나누어 짐.

#### 프로세스 목록 보기

- `ps + 옵션`
  - option(조합가능):\
    `-e` : 현재 실행 중인 모든 프로세스 정보 출력.\
    `-f` : 모든 정보 확인.\
    `-a` : 실행중인 전체 사용자의 모든 프로세스 출력.\
    `-u` : 프로세스를 실행한 사용자와 프로세스 시작 시간 등을 함께 출력.\
    `-x` : 터미널 제어 없이 프로세스 현황 보기, 실시간으로 출력.

- UID : 유저의 고유 ID
- PID : 프로세스 ID.
- PPID : 부모 프로세스의 ID(0은 init, 1은 kernel threadd)
- STIME : 프로세스가 시작된 시간(월:일 또는 시:분:초로 나타냄)
- TTY : 프로세스가 연결된 terminal 번호.
- TIME : 프로세스가 생성되고 지난 시간.
- CMD : 프로세스의 이름.

#### 프로세스 종료

- `kill + 옵션 + PID:프로세스 아이디`
  - option :\
    `-l` : 사용가능한 시그널 목록 출력
  - 자주 사용하는 시그널 :\
    `-1` : 재실행(SIGHUP)\
    `-9` : 강제종료(SIGKILL)\
    `-15` : 정상종료(SIGTERM)

#### 프로세스 종료 예시

`kill -9 PID`: 해당 PID를 강제 종료

### 서비스 관리와 systemctl

리눅스에서 터미널을 이용해 실행시키는 거의 모든 명령어는 foreground에서 실행.\
foreground는 보이는 화면에서 그대로 작동하는 것을 의미.\
보고 있지 않은 상태에서도 해당 명령어를 실행되고 있게 하기 위해서는 명령어 뒤에 `&`를 붙여 background에서 실행되게 할 수 있음.

`job`은 백그라운드에서 실행되는 작업을 보여주는 명령어.\
터미널 명령을 통한 작업만을 의미.\
`job`을 통해 프로세스를 실생할 수 있지만 터미널이 종료되면 job과 함께 프로세스도 종료.\
각각의 터미널마다 `job`은 따로 존재.\
`job` 으로 foreground와 background 를 효율적으로 관리 할 수 있음.

프로세스와 마찬가지로 `kill` 명령어를 통해 종료 가능.\
`ps` 명령어를 통해 PID를 알아내어 종료하는 방법도 가능.

- `kill + %작업번호`: 종료

- `jobs`: 실행중인 background 프로세스를 출력, 출력물의 앞에 나오는 숫자는 job의 작업번호.

- `fg + 작업번호`: 포그라운드로 프로세스 실행

- `bg + 작업번호`: 백그라운드로 프로세스 실행

### 네트워크 설정과 관리

`at`는 지정된 시간에 1회 실행되는 작업 예약 명령어.
시간이 되면 해당 명령어가 실행 되고 `at`의 list에서 사라짐

#### 기본 형태

- `at + 옵션 + 시간 + 날짜 + +증가시간`
  - option :\
    `-m` : 출력 결과가 없더라도 작업이 완료될 때 사용자에게 메일을 보냄.\
    `-f` + 파일명 : 스크립트 파일 등을 실행할 때 사용.\
    `-l` : 예약된 작업 목록 출력, atq 명령어 또한 같은 동작을 수행.\
    `-v` : 작업이 수행될 시간 출력.\
    `-d` : 예약된 작업을 삭제, atrm 명령어 또한 같은 동작을 수행.

- `atq`: 실행 예약이 된 at의 list를 보여줌

- `atrm + at번호`: `atq`를 이용하여 list up 한 list에서 해당 at번호의 at를 삭제.

#### at 예시

- `at now + 3hours -f zima.sh`: 지금으로부터 3시간 후에 zima.sh 스크립트를 실행.

crontab은 지정된 시간에 1회 실행되는 at과는 달리 지정된 시간에 따라 주기적으로 실행.

#### 기본형태

- crontab + 옵션 + 옵션에서 요구하는 텍스트
  - option :\
    `-l` : 현재 계정의 설정된 crontab 정보를 보여줌.\
    `-e` : 현재 계정의 corntab 정보를 수정.\
    `-r` : 현재 계정의 crontab 정보를 모두 삭제.\
    `-u` : 특정 사용자의 crontab 정보를 다루게 해줌(root 권한 필요).

### 리눅스에서의 사용자 계정 관리

SSH(Secure Shell)는 다른 컴퓨터에 접근하거나 그 컴퓨터에서 명령 실행 등을 할 수 있도록 해주는 프로토콜.

Telnet은 SSH 와 유사하지만 보안적으로 매우 치명적인 결함 존재.\
Telnet을 통해 보내지는 패킷 데이터는 암호화 되어 있지 않음.\
이를 통해 사용자의 비밀번호 등의 노출되어서는 안되는 데이터다 노출.

SSH는 데이터를 암호화 가능.

우분투에서는 openssh 라는 패키지를 통해 SSH 구동 가능.\
openssh-client 가 기본으로 설치되고 다른 컴퓨터에서 우분투에 접속하려면 openssh-server 패키지를 설치해야 함.

- `dpkg -l | grep openssh`: openssh 설치 여부 확인 가능.
- `sudo apt-get install openssh-server`: openssh-server 설치 가능.
- `sudo service ssh start`: ssh 서버 실행 가능.
- `sudo service ssh stop`: ssh 서버 중지 가능.
- `sudo service ssh restart`: 명령어를 통해 ssh 서버 재실행 가능.
- `server --status-all | grep +`: 명령어를 통해 ssh 서버 확인 가능
- `sudo netstat -antp`: 명령어를 통해 ssh 포트 및 상태 확인 가능
- `ssh + 서버아이디@아이피 혹은 서버이름 혹은 도메인`: CMD 또는 터미널 창에서 다음의 명령어로 접속 가능.\
단, OpenSSH Client가 설치되어 있어야 함.

Window의 경우 Windows 10 으로 버젼이 업그레이드 되면서 openssh client를 Windows 터미널인 powershell에 설치 할 수 있게 됨.

#### 참고 링크

<https://docs.microsoft.com/ko-kr/windows-server/administration/openssh/openssh_install_firstuse>
